definition

%% TODO: 
%%       NotIn
%%       RegExp
%%       No ExpStmt if '{' or 'function'
%%       Tidy up cons
%%       Rename productions
%%       Hide productions ?

%% ECMA-262 ECMAScript 5.1
%% Missing full Unicode support
    
%% Layout
%% 7.2 Whitespace    
%% 7.3 Line Terminators
%% 7.4 Comments      
module ecmascript-51/Layout
  exports
      
    lexical syntax
      [\ \t\12\r\n] -> LAYOUT
    
      [\n]   -> LineTerminatorSequence
      CR     -> LineTerminatorSequence
      [\r][\n] -> LineTerminatorSequence
      [\r]   -> CR
      
      "//" ~[\r\n]*                 -> LAYOUT
      "/*" (~[\*] | Asterisk)* "*/" -> LAYOUT
      [\*]                          -> Asterisk

      -> EOF

    lexical restrictions
      CR -/- [\n]
      Asterisk -/- [\/]
      EOF -/- ~[]

    context-free restrictions
      LAYOUT? -/- [\ \t\12\n\r] | [\/]/[\/] | [\/].[\*]

%% 7.6 Identifiers; No Unicode escape support
%% 7.6.1 Reserved Words
module ecmascript-51/Identifiers
  exports
    
    context-free syntax
      IdentifierName -> Identifier {cons("Identifier")}
      ReservedWord -> Identifier {reject}
        
    lexical syntax
      [A-Za-z\$\_][A-Za-z0-9\$\_]*  -> IdentifierName
    
    lexical restrictions
      IdentifierName -/- [A-Za-z0-9\$\_]
    
    lexical syntax
      "break"      -> Keyword
      "case"       -> Keyword
      "catch"      -> Keyword
      "continue"   -> Keyword
      "debugger"   -> Keyword
      "default"    -> Keyword
      "delete"     -> Keyword
      "do"         -> Keyword
      "else"       -> Keyword
      "finally"    -> Keyword
      "for"        -> Keyword
      "function"   -> Keyword
      "if"         -> Keyword
      "in"         -> Keyword
      "instanceof" -> Keyword
      "new"        -> Keyword
      "return"     -> Keyword
      "switch"     -> Keyword
      "this"       -> Keyword
      "throw"      -> Keyword
      "try"        -> Keyword
      "typeof"     -> Keyword
      "var"        -> Keyword
      "void"       -> Keyword
      "while"      -> Keyword
      "with"       -> Keyword
      
      "class"      -> FutureReservedWord
      "const"      -> FutureReservedWord
      "enum"       -> FutureReservedWord
      "export"     -> FutureReservedWord
      "extends"    -> FutureReservedWord
      "import"     -> FutureReservedWord
      "super"      -> FutureReservedWord
      "implements" -> FutureReservedWord
      "interface"  -> FutureReservedWord
      "let"        -> FutureReservedWord
      "package"    -> FutureReservedWord
      "private"    -> FutureReservedWord
      "protected"  -> FutureReservedWord
      "public"     -> FutureReservedWord
      "static"     -> FutureReservedWord
      "yeild"      -> FutureReservedWord

      Keyword            -> ReservedWord
      FutureReservedWord -> ReservedWord
      NullLiteral        -> ReservedWord
      BooleanLiteral     -> ReservedWord
      
      lexical restrictions
        Keyword FutureReservedWord -/- [A-Za-z0-9\$\_]

%% 7.8 Literals        
%% 7.8.1 Null Literals
%% 7.8.2 Boolean Literals
%% 7.8.3 Numeric Literals
%% 7.8.4 String Literals
%% TODO 7.8.5 regular Expression Literals
module ecmascript-51/Literals
  exports
    
    context-free syntax
    NullLiteral -> Literal
    BooleanLiteral -> Literal
    NumericLiteral -> Literal
    StringLiteral -> Literal
    %% RegularExpressionLiteral -> Literal
      
    lexical syntax
      "null"    -> NullLiteral

    lexical restrictions
      NullLiteral -/- [A-Za-z0-9\$\_]
        
    lexical syntax        
      "true"    -> BooleanLiteral
      "false"   -> BooleanLiteral

    lexical restrictions
      BooleanLiteral -/- [A-Za-z0-9\$\_]

    context-free syntax
      DecimalLiteral    -> NumericLiteral {cons("Num")}
      HexIntegerLiteral -> NumericLiteral {cons("HexNum")}
              
    lexical syntax
      "0"         -> DecimalIntegerLiteral
      [1-9][0-9]* -> DecimalIntegerLiteral
      
      
      DecimalIntegerLiteral "." [0-9]* ExponentPart? -> DecimalLiteral
      "." [0-9]+ ExponentPart? -> DecimalLiteral
      DecimalIntegerLiteral ExponentPart? -> DecimalLiteral
      
      [eE] SignedInteger -> ExponentPart
      [\+\-]? [0-9]+ -> SignedInteger
      
      [0][xX][0-9a-fA-F]+ -> HexIntegerLiteral
      
    lexical restrictions
      DecimalIntegerLiteral DecimalLiteral SignedInteger -/- [0-9]
      HexIntegerLiteral -/- [0-9a-fA-F]
        
    context-free syntax
      DoubleQuotedString   -> StringLiteral {cons("DoubleQuotedString")}
      SingleQuotedString  -> StringLiteral {cons("SingleQuotedString")}
        
    lexical syntax
      "\"" DoubleStringChar* "\""   -> DoubleQuotedString
      "'" SingleStringChar* "'"  -> SingleQuotedString

      ~[\"\\\r\n] -> DoubleStringChar
      [\\] EscapeSequence -> DoubleStringChar
      [\\] LineTerminatorSequence -> DoubleStringChar
      
      ~[\'\\\r\n] -> SingleStringChar
      [\\] EscapeSequence -> SingleStringChar
      [\\] LineTerminatorSequence -> SingleStringChar
      
      Zero -> EscapeSequence
      ~[0-9xu\r\n] -> EscapeSequence
      [x][0-9a-fA-F][0-9a-fA-F] -> EscapeSequence
      [u][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F] -> EscapeSequence
      
      [0] -> Zero
      
    lexical restrictions
      Zero -/- [0-9]
        
%% 7.9 Automatic Semicolon Insertion
%% All {} enclosed statement lists should use OpenBlock and CloseBlock rather than "{" and "}"
%% Any statement that supports auto semicolon insertion should -> AutoSemiStatement 
%% Other statements should -> Statement
module ecmascript-51/AutoSemiInsertion
  exports
   
    context-free syntax 
      "{" -> OpenBlock {cons("OpenBlk")}
      "}" -> CloseBlock {cons("CloseBlk")}
      AutoSemiStatement "}" -> CloseBlock {cons("AutoCloseBlk"), layout("1.last.line==2.first.line")}

      SemiStatement -> Statement {longest-match}

      AutoSemiStatement ";" -> SemiStatement {cons("SemiStm")}
      AutoSemiStatement LAYOUT? -> SemiStatement {cons("AutoStm"), enforce-newline}
      AutoSemiStatement EOF -> SemiStatement {cons("EOFStm"), avoid}
 
%% 11 Expressions
module ecmascript-51/Expressions
  exports
   
    context-free syntax
      %% 11.1 Primary Expressions
      "this" -> PrimaryExpression {cons("ThisExpr")}
      Identifier -> PrimaryExpression {cons("IdExpr")}
      Literal -> PrimaryExpression {cons("LitExpr")}
      ArrayLiteral -> PrimaryExpression {cons("ArrLitExpr")}
      ObjectLiteral -> PrimaryExpression {cons("ObjLitExpr")}
      "(" Expression ")" -> PrimaryExpression {cons("ParenExpr")}
      
     "[" Comma* "]" -> ArrayLiteral {cons("ArrayLiteral")}
     "[" Comma* ElementList Comma* "]" -> ArrayLiteral {cons("ArrayLiteral")}
     AssignmentExpression -> ElementList {cons("ElementList")}
     ElementList Comma+ AssignmentExpression -> ElementList {cons("ElementList")}
      
    lexical syntax
      "," -> Comma   

    context-free syntax
      "{" {PropertyAssignment ","}* "}" -> ObjectLiteral {cons("ObjectLiteral")}
      "{" {PropertyAssignment ","}* "," "}" -> ObjectLiteral {cons("ObjectLiteral")}
      PropertyName ":" AssignmentExpression -> PropertyAssignment {cons("PropertyAssignment")}
      "get" PropertyName "(" ")" FunctionBodyBlock -> PropertyAssignment {cons("PropertyGet")}
      "set" PropertyName "(" Identifier ")" FunctionBodyBlock -> PropertyAssignment {cons("PropertySet")}
      IdentifierName -> PropertyName
      StringLiteral -> PropertyName
      NumericLiteral -> PropertyName
      
    context-free syntax
      %% 11.2 Left Hand Side Expressions
      PrimaryExpression -> MemberExpression
      FunctionExpression -> MemberExpression
      MemberExpression "[" Expression "]" -> MemberExpression {cons("MbrIndex")}
      MemberExpression "." IdentifierName -> MemberExpression {cons("MbrMbr")}
      "new" MemberExpression Arguments -> MemberExpression {cons("NewMbr")}

      MemberExpression -> NewExpression
      "new"+ MemberExpression -> NewExpression {cons("NewExp")}

      MemberExpression Arguments -> CallExpression {cons("CallArgs")}
      CallExpression Arguments -> CallExpression {cons("CallArgs")}
      CallExpression "[" Expression "]" -> CallExpression {cons("CallIndex")}
      CallExpression "." IdentifierName -> CallExpression {cons("CallMbr")}        
      
      "(" {AssignmentExpression ","}* ")" -> Arguments {cons("Args")}

      NewExpression -> LeftHandSideExpression {cons("LHS")}
      CallExpression -> LeftHandSideExpression {cons("LHS")}    

      LeftHandSideExpression -> Expression
          
    context-free priorities
    {right:  
      Expression "++" -> Expression {cons("PostInc"), layout("1.last.line==2.first.line")}
      Expression "--" -> Expression {cons("PostDec"), layout("1.last.line==2.first.line")} 
    }
    >
    {
      "delete" Expression -> Expression {cons("Delete")}
      "void" Expression -> Expression {cons("Void")}
      "typeof" Expression -> Expression {cons("Typeof")}
      "++" Expression -> Expression {cons("PreInc")}
      "--" Expression -> Expression {cons("PreDec")}
      "+" Expression -> Expression {cons("UnaryPlus")}
      "-" Expression -> Expression {cons("UnaryMinus")}
      "~" Expression -> Expression {cons("BitNot")}
      "!" Expression -> Expression {cons("Not")}
    }
    >
    {left:
      Expression "*" Expression -> Expression {cons("Times")}
      Expression "/" Expression -> Expression {cons("Divide")}
      Expression "%" Expression -> Expression {cons("Remainder")} 
    }
    >
    {left:
      Expression "+" Expression -> Expression {cons("Plus")}
      Expression "-" Expression -> Expression {cons("Minus")}
    }
    >
    {left:
      Expression "<<" Expression -> Expression {cons("LeftShift")}
      Expression ">>" Expression -> Expression {cons("SignRightShift")}
      Expression ">>>" Expression -> Expression {cons("NoSignRightShift")}
    }
    >
    {left:
      Expression "<" Expression -> Expression {cons("LessThan")}
      Expression ">" Expression -> Expression {cons("GreaterThan")}
      Expression "<=" Expression -> Expression {cons("LessEquals")}
      Expression "<=" Expression -> Expression {cons("GreateEquals")}
      Expression "instanceof" Expression -> Expression {cons("InstanceOf")}
      Expression "in" Expression -> InExpression {cons("In")}
      InExpression -> Expression 
    }
    >
    {left:
      Expression "==" Expression -> Expression {cons("Equals")}
      Expression "!=" Expression -> Expression {cons("NotEquals")}
      Expression "===" Expression -> Expresson {cons("StrictEquals")}
      Expression "!==" Expression -> Expression {cons("StrictNotEquals")}
    }
    >
      Expression "&" Expression -> Expression {left,cons("BitAnd")}
    >
      Expression "^" Expression -> Expression {left,cons("BitXor")}
    >
      Expression "|" Expression -> Expression {left,cons("BitOr")}
    >
      Expression "&&" Expression -> Expression {left,cons("And")}
    >
      Expression "||" Expression -> Expression {left,cons("Or")}
    >
      Expression CondMid Expression -> Expression {right, cons("Cond")}
    >
    {right:
      LeftHandSideExpression "=" Expression -> Expression {cons("Assign")}
      LeftHandSideExpression "*=" Expression -> Expression {cons("AssignMul")}
      LeftHandSideExpression "/=" Expression -> Expression {cons("AssignDiv")}
      LeftHandSideExpression "%=" Expression -> Expression {cons("AssignRem")}
      LeftHandSideExpression "+=" Expression -> Expression {cons("AssignPlus")}
      LeftHandSideExpression "-=" Expression -> Expression {cons("AssignMinus")}
      LeftHandSideExpression "<<=" Expression -> Expression {cons("AssignLeftShift")}
      LeftHandSideExpression ">>=" Expression -> Expression {cons("AssignSRightShift")}
      LeftHandSideExpression ">>>=" Expression -> Expression {cons("AssignURightShift")}
      LeftHandSideExpression "&=" Expression -> Expression {cons("AssignAnd")}
      LeftHandSideExpression "^=" Expression -> Expression {cons("AssignXor")}
      LeftHandSideExpression "|=" Expression -> Expression {cons("AssignOr")}
    }
    >
      Expression -> AssignmentExpression
    >
      Expression "," Expression -> Expression {left, cons("Comma")}

    context-free syntax  
      Expression -> ExpressionNoIn
      InExpression -> ExpressionNoIn {reject}
      AssignmentExpression -> AssignmentExpressionNoIn
      InExpression -> AssignmentExpressionNoIn {reject}
      
      "?" Expression ":" -> CondMid{bracket}
           
    lexical restrictions
	    "+" -/- [\+]
	    "-" -/- [\-]
	    "/" -/- [\/]
      
%% 12 Statements
module ecmascript-51/Statements
  exports
    
    context-free syntax
      %% 12.1 Block
      Block -> Statement
    	OpenBlock Statement* CloseBlock -> Block {cons("Block")}
      
      %% 12.2 Variable statement
      "var" {VarDeclaration ","}+ -> AutoSemiStatement {cons("VarStm")}
      Identifier Initialiser? -> VarDeclaration {cons("VarDec")}
      "=" AssignmentExpression -> Initialiser {cons("VarInit")}
      
      %% 12.3 Empty Statement
      ";" -> Statement {cons("EmptyStm")}   
      
      %% 12.4 Expression Statement
      %% TODO: reject expressions starting with { or 'function'
      Expression -> AutoSemiStatement {cons("ExprStm")}
      
      %% 12.5 if Statement
      "if" "(" Expression ")" Statement -> Statement {cons("IfStm"), prefer}
      "if" "(" Expression ")" Statement "else" Statement -> Statement {cons("IfElseStm")}
      
      %% 12.6.1 do-while Statement
      "do" Statement "while" "(" Expression ")" -> AutoSemiStatement {cons("DoStm")}
      
      %% 12.6.2 while Statement
      "while" "(" Expression ")" Statement -> Statement {cons("WhileStm")}
      
      %% 12.6.3 for Statement
      %% TODO: no-in handling
      "for" "(" Expression? ";" Expression? ";" Expression? ")" Statement -> Statement {cons("ForSmt")}
      "for" "(" "var" {VarDeclaration ","}+ ";" Expression? ";" Expression? ")" Statement -> Statement {cons("ForSmt")}
      
      %% 12.6.4 for-in Statement
      %% TODO: no-in handling
      "for" "(" LeftHandSideExpression "in" Expression ")" Statement -> Statement {cons("ForInStm")}
      "for" "(" "var" VarDeclaration "in" Expression ")" Statement -> Statement {cons("ForInStm")}
      
      %% 12.7 continue Statement
      "continue" -> AutoSemiStatement {cons("ContinueStm")}
      "continue" Identifier -> AutoSemiStatement {cons("ContinueStm"), layout("1.first.line == 2.first.line")}
      
      %% 12.8 break Statement
      "break" -> AutoSemiStatement {cons("BreakStm")}
      "break" Identifier -> AutoSemiStatement {cons("BreakStm"), layout("1.first.line == 2.first.line")}
      
      %% 12.9 return Statement
      "return" -> AutoSemiStatement {cons("ReturnStm")}
      "return" Expression -> AutoSemiStatement {cons("ReturnStm"), layout("1.first.line == 2.first.line")}
     
      %% 12.10 with Statement
      %% Not implemented, considered dangerous

      %% 12.11 switch Statement
      "switch" "(" Expression ")" CaseBlock -> Statement {cons("SwitchStm")}
      OpenBlock CaseClause* CloseBlock -> CaseBlock {cons("CaseBlock")}
      "case" Expression ":" Statement* -> CaseClause {cons("Case")}
      "default" ":" Statement* -> CaseClause {cons("Default")}
      
      %% 12.12 Labelled Statements
      Identifier ":" Statement -> Statement {cons("LabelledStm")}
      
      %% 12.13 throw Statement
      "throw" Expression -> AutoSemiStatement {cons("ThrowStm"), layout("1.first.line == 2.first.line")}
      
      %% 12.14 try Statement
      "try" Block Catch? Finally? -> Statement {cons("TryStm")}
      "catch" "(" Identifier ")" Block -> Catch {cons("Catch")}
      "finally" Block -> Finally {cons("Finally")}

      %% 12.15 debugger Statement
      "debugger" -> Statement {cons("DebuggerStm")}
      
%% 13 Function Declaration
module ecmascript-51/Functions
  exports

    context-free syntax
      "function" Identifier "(" {Identifier ","}* ")" FunctionBodyBlock -> FunctionDeclaration {cons("FunDec")}
      "function" Identifier? "(" {Identifier ","}* ")" FunctionBodyBlock -> FunctionExpression {cons("FunExp")}
      
      OpenBlock SourceElement* CloseBlock -> FunctionBodyBlock {cons("FnBody")}
   
%% 14 Program
module ecmascript-51/Program
  exports
    
    context-free start-symbols
      Program
    
    context-free syntax
      SourceElement* -> Program {cons("Program")}

      Statement -> SourceElement
      FunctionDeclaration -> SourceElement
 
module ECMAScript-51
imports
  ecmascript-51/Program
  ecmascript-51/Functions
  ecmascript-51/Statements
  ecmascript-51/Expressions
  ecmascript-51/AutoSemiInsertion
  ecmascript-51/Literals
  ecmascript-51/Identifiers
  ecmascript-51/Layout
  
module org/sugarj/languages/JavaScript
imports ECMAScript-51
  [ Program   =>    JavaScriptProgram
    SourceElement => JavaScriptSourceElement
    Statement => JavaScriptStatement
    Expression => JavaScriptExpression
    ReservedWord => JavaScriptReservedWord
    Identifier => JavaScriptIdentifier
    NullLiteral => JavaScriptNullLiteral
    BooleanLiteral => JavaScriptBooleanLiteral
    LineTerminatorSequence => JavaScriptLineTerminatorSequence
    NumericLiteral => JavaScriptNumericLiteral
    StringLiteral => JavaScriptStringLiteral ]