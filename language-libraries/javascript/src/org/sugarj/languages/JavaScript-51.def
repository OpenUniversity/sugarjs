definition

%% TODO: 
%%       RegExp
%%       No ExpStmt if '{' or 'function'
%%       Rename productions -> JavaScript...
%%       Hide productions ?
%%       Ought to implement 'with' statement

%% ECMA-262 ECMAScript 5.1
%% Missing full Unicode support
    
%% Layout
%% 7.2 Whitespace    
%% 7.3 Line Terminators
%% 7.4 Comments      
module ecmascript-51/Layout
  exports
      
    lexical syntax
      [\ \t\12\r\n] -> LAYOUT
    
      [\n]   -> LineTerminatorSequence
      CR     -> LineTerminatorSequence
      [\r][\n] -> LineTerminatorSequence
      [\r]   -> CR
      
      "//" ~[\r\n]*                 -> LAYOUT
      "/*" (~[\*] | Asterisk)* "*/" -> LAYOUT
      [\*]                          -> Asterisk

    lexical restrictions
      CR -/- [\n]
      Asterisk -/- [\/]

    context-free restrictions
      LAYOUT? -/- [\ \t\12\n\r] | [\/]/[\/] | [\/].[\*]

%% 7.6 Identifiers; No Unicode escape support
%% 7.6.1 Reserved Words
module ecmascript-51/Identifiers
  exports
    
    context-free syntax
      IdentifierName -> Identifier {cons("Identifier")}
      ReservedWord -> Identifier {reject}
        
    lexical syntax
      [A-Za-z\$\_][A-Za-z0-9\$\_]*  -> IdentifierName
    
    lexical restrictions
      IdentifierName -/- [A-Za-z0-9\$\_]
    
    lexical syntax
      "break"      -> Keyword
      "case"       -> Keyword
      "catch"      -> Keyword
      "continue"   -> Keyword
      "debugger"   -> Keyword
      "default"    -> Keyword
      "delete"     -> Keyword
      "do"         -> Keyword
      "else"       -> Keyword
      "finally"    -> Keyword
      "for"        -> Keyword
      "function"   -> Keyword
      "if"         -> Keyword
      "in"         -> Keyword
      "instanceof" -> Keyword
      "new"        -> Keyword
      "return"     -> Keyword
      "switch"     -> Keyword
      "this"       -> Keyword
      "throw"      -> Keyword
      "try"        -> Keyword
      "typeof"     -> Keyword
      "var"        -> Keyword
      "void"       -> Keyword
      "while"      -> Keyword
      "with"       -> Keyword
      
      "class"      -> FutureReservedWord
      "const"      -> FutureReservedWord
      "enum"       -> FutureReservedWord
      "export"     -> FutureReservedWord
      "extends"    -> FutureReservedWord
      "import"     -> FutureReservedWord
      "super"      -> FutureReservedWord
      "implements" -> FutureReservedWord
      "interface"  -> FutureReservedWord
      "let"        -> FutureReservedWord
      "package"    -> FutureReservedWord
      "private"    -> FutureReservedWord
      "protected"  -> FutureReservedWord
      "public"     -> FutureReservedWord
      "static"     -> FutureReservedWord
      "yeild"      -> FutureReservedWord

      Keyword            -> ReservedWord
      FutureReservedWord -> ReservedWord
      "null"             -> ReservedWord
      "true"             -> ReservedWord
      "false"            -> ReservedWord
      
      lexical restrictions
        ReservedWord -/- [A-Za-z0-9\$\_]

%% 7.8 Literals        
%% 7.8.1 Null Literals
%% 7.8.2 Boolean Literals
%% 7.8.3 Numeric Literals
%% 7.8.4 String Literals
%% TODO 7.8.5 regular Expression Literals
module ecmascript-51/Literals
  exports
    
    context-free syntax
      NullLiteral    -> Literal {cons("Null")}
      BooleanLiteral -> Literal {cons("Boolean")}
      NumericLiteral -> Literal {cons("Number")}
      StringLiteral  -> Literal {cons("String")}
      %% RegularExpressionLiteral -> Literal
      
      "null"    -> NullLiteral
      "true"    -> BooleanLiteral {cons("True")}
      "false"   -> BooleanLiteral {cons("False")}

      DecimalLiteral    -> NumericLiteral {cons("Decimal")}
      HexIntegerLiteral -> NumericLiteral {cons("HexInt")}
              
    lexical syntax
      "0"         -> DecimalIntegerLiteral
      [1-9][0-9]* -> DecimalIntegerLiteral
      
      
      DecimalIntegerLiteral "." [0-9]* ExponentPart? -> DecimalLiteral
      "." [0-9]+ ExponentPart?                       -> DecimalLiteral
      DecimalIntegerLiteral ExponentPart?            -> DecimalLiteral
      
      [eE] SignedInteger -> ExponentPart
      [\+\-]? [0-9]+     -> SignedInteger
      
      [0][xX][0-9a-fA-F]+ -> HexIntegerLiteral
      
    lexical restrictions
      DecimalIntegerLiteral DecimalLiteral SignedInteger -/- [0-9]
      HexIntegerLiteral -/- [0-9a-fA-F]
        
    context-free syntax
      DoubleQuotedString  -> StringLiteral {cons("DoubleQuotedString")}
      SingleQuotedString  -> StringLiteral {cons("SingleQuotedString")}
        
    lexical syntax
      "\"" DoubleStringChar* "\"" -> DoubleQuotedString
      "'" SingleStringChar* "'"   -> SingleQuotedString

      ~[\"\\\r\n]                 -> DoubleStringChar
      [\\] EscapeSequence         -> DoubleStringChar
      [\\] LineTerminatorSequence -> DoubleStringChar
      
      ~[\'\\\r\n]                 -> SingleStringChar
      [\\] EscapeSequence         -> SingleStringChar
      [\\] LineTerminatorSequence -> SingleStringChar
      
      Zero                                            -> EscapeSequence
      ~[0-9xu\r\n]                                    -> EscapeSequence
      [x][0-9a-fA-F][0-9a-fA-F]                       -> EscapeSequence
      [u][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F] -> EscapeSequence
      
      [0] -> Zero
      
    lexical restrictions
      Zero -/- [0-9]
        
%% 7.9 Automatic Semicolon Insertion
%% Any statement that requires auto semicolon insertion should -> AutoSemiStatement 
%% Other statements should -> Statement
module ecmascript-51/AutoSemiInsertion
  exports
   
    context-free syntax 
      SemiStatement         -> Statement {longest-match}

      AutoSemiStatement ";" -> SemiStatement {cons("SemiStm")}
      
      %% These all have empty final productions to have to be careful about ambiguity
      %% NLStm - statement without semicolon followed by newline
      %% EOFStm - statement without semicolon followed by End of File, no newline
      %% EOBStm - statement without semicolon followed by } before any newline
      AutoSemiStatement NL  -> SemiStatement {cons("NLStm"), enforce-newline, prefer}
      AutoSemiStatement EOF -> SemiStatement {cons("EOFStm")}
      AutoSemiStatement EOB -> SemiStatement {cons("EOBStm"), avoid}
      
    lexical syntax
      -> NL
      -> EOB 
      -> EOF
      
    lexical restrictions
      EOB -/- ~[\}]
      EOF -/- ~[]
 
%% 11 Expressions
module ecmascript-51/Expressions
  exports
   
    %% Using priorities is a useful way to describe operator precedence but does not make
    %% it easy to specify precedence of new operators, the extending code would have to use
    %% productions from the original grammar 
    %% Naming expression productions P1Expression, P2Expression and so on is not so neat
    %% but will make it easier to specify the precedence of a new operator    
    context-free syntax
      %% 11.1 Primary Expressions
      "this"             -> P19Expression {cons("This")}
      Identifier         -> P19Expression
      Literal            -> P19Expression
      ArrayLiteral       -> P19Expression
      ObjectLiteral      -> P19Expression
      "(" Expression ")" -> P19Expression {cons("Paren")}
      
    "[" "]"                     -> ArrayLiteral {cons("ArrayLiteral"), prefer}
    "[" {ArrayElement ","}+ "]" -> ArrayLiteral {cons("Array")}
    
                         -> ArrayElement {cons("MissingElement")}
    AssignmentExpression -> ArrayElement {cons("Element")}
          
    context-free syntax
      "{" {PropertyAssignment ","}* "}"     -> ObjectLiteral {cons("Object")}
      "{" {PropertyAssignment ","}* "," "}" -> ObjectLiteral {cons("Object")}
      
      PropertyName ":" AssignmentExpression                      -> PropertyAssignment {cons("PropertyAssignment")}
      "get" PropertyName "(" ")" "{" FunctionBody "}"            -> PropertyAssignment {cons("PropertyGet")}
      "set" PropertyName "(" Identifier ")" "{" FunctionBody "}" -> PropertyAssignment {cons("PropertySet")}
      
      IdentifierName -> PropertyName
      StringLiteral  -> PropertyName
      NumericLiteral -> PropertyName
      
    context-free syntax
      %% 11.2 Left Hand Side Expressions
      P19Expression                    -> P18Expression
      FunctionExpression               -> P18Expression
      P18Expression "[" Expression "]" -> P18Expression {cons("ArrayAccess")}
      P18Expression "." MemberName     -> P18Expression {cons("MemberAccess")}
      "new" P18Expression Arguments    -> P18Expression {cons("NewArgs")}

      P18Expression         -> P17aExpression
      "new"+ P17aExpression -> P17aExpression {cons("New")}

      P18Expression Arguments           -> P17bExpression {cons("Call")}
      P17bExpression Arguments          -> P17bExpression {cons("Call")}
      P17bExpression "[" Expression "]" -> P17bExpression {cons("ArrayAccess")}
      P17bExpression "." MemberName     -> P17bExpression {cons("MemberAccess")}        
      
      "(" {AssignmentExpression ","}* ")" -> Arguments {cons("Args")}
      
      IdentifierName -> MemberName {cons("MemberName")}

      P17aExpression -> P16Expression
      P17bExpression -> P16Expression    

      P16Expression -> LeftHandSideExpression
      
      P16Expression      -> P15Expression    
      P16Expression "++" -> P15Expression {cons("PostInc"), layout("1.last.line==2.first.line")}
      P16Expression "--" -> P15Expression {cons("PostDec"), layout("1.last.line==2.first.line")} 
 
      P15Expression          -> P14Expression
      "delete" P15Expression -> P14Expression {cons("Delete")}
      "void" P15Expression   -> P14Expression {cons("Void")}
      "typeof" P15Expression -> P14Expression {cons("Typeof")}
      "++" P15Expression     -> P14Expression {cons("PreInc")}
      "--" P15Expression     -> P14Expression {cons("PreDec")}
      "+" P15Expression      -> P14Expression {cons("UnaryPlus")}
      "-" P15Expression      -> P14Expression {cons("UnaryMinus")}
      "~" P15Expression      -> P14Expression {cons("BitNot")}
      "!" P15Expression      -> P14Expression {cons("Not")}
 
      P14Expression                   -> P13Expression
      P13Expression "*" P14Expression -> P13Expression {cons("Times")}
      P13Expression "/" P14Expression -> P13Expression {cons("Divide")}
      P13Expression "%" P14Expression -> P13Expression {cons("Remainder")} 
 
      P13Expression                   -> P12Expression
      P12Expression "+" P13Expression -> P12Expression {cons("Plus")}
      P12Expression "-" P13Expression -> P12Expression {cons("Minus")}
 
      P12Expression                     -> P11Expression
      P11Expression "<<" P12Expression  -> P11Expression {cons("LeftShift")}
      P11Expression ">>" P12Expression  -> P11Expression {cons("RightShift")}
      P11Expression ">>>" P12Expression -> P11Expression {cons("URightShift")}
 
      P11Expression                            -> P10Expression
      P10Expression "<" P11Expression          -> P10Expression {cons("LessThan")}
      P10Expression ">" P11Expression          -> P10Expression {cons("GreaterThan")}
      P10Expression "<=" P11Expression         -> P10Expression {cons("LessEquals")}
      P10Expression "<=" P11Expression         -> P10Expression {cons("GreateEquals")}
      P10Expression "instanceof" P11Expression -> P10Expression {cons("InstanceOf")}
      %% Keep track of in expressions as required elsewhere
      P10Expression "in" P11Expression         -> InExpression {cons("In")}
      InExpression                             -> P10Expression 
 
      P10Expression                    -> P9Expression
      P9Expression "==" P10Expression  -> P9Expression {cons("Equals")}
      P9Expression "!=" P10Expression  -> P9Expression {cons("NotEquals")}
      P9Expression "===" P10Expression -> P9Expresson {cons("StrictEquals")}
      P9Expression "!==" P10Expression -> P9Expression {cons("StrictNotEquals")}
 
      P9Expression                  -> P8Expression
      P8Expression "&" P9Expression -> P8Expression {cons("BitAnd")}
 
      P8Expression                  -> P7Expression
      P7Expression "^" P8Expression -> P7Expression {cons("BitXor")}
 
      P7Expression                  -> P6Expression
      P6Expression "|" P7Expression -> P6Expression {cons("BitOr")}
 
      P6Expression                   -> P5Expression
      P5Expression "&&" P6Expression -> P5Expression {cons("And")}
 
      P5Expression                   -> P4Expression
      P4Expression "||" P5Expression -> P5Expression {cons("Or")}
 
      P4Expression                                   -> P3Expression
      P4Expression "?" P2Expression ":" P2Expression -> P3Expression {cons("Cond")}
 
      P3Expression                               -> P2Expression
      LeftHandSideExpression "=" P2Expression    -> P2Expression {cons("Assign")}
      LeftHandSideExpression "*=" P2Expression   -> P2Expression {cons("AssignMul")}
      LeftHandSideExpression "/=" P2Expression   -> P2Expression {cons("AssignDiv")}
      LeftHandSideExpression "%=" P2Expression   -> P2Expression {cons("AssignRem")}
      LeftHandSideExpression "+=" P2Expression   -> P2Expression {cons("AssignPlus")}
      LeftHandSideExpression "-=" P2Expression   -> P2Expression {cons("AssignMinus")}
      LeftHandSideExpression "<<=" P2Expression  -> P2Expression {cons("AssignLeftShift")}
      LeftHandSideExpression ">>=" P2Expression  -> P2Expression {cons("AssignRightShift")}
      LeftHandSideExpression ">>>=" P2Expression -> P2Expression {cons("AssignURightShift")}
      LeftHandSideExpression "&=" P2Expression   -> P2Expression {cons("AssignAnd")}
      LeftHandSideExpression "^=" P2Expression   -> P2Expression {cons("AssignXor")}
      LeftHandSideExpression "|=" P2Expression   -> P2Expression {cons("AssignOr")}
      P2Expression                               -> AssignmentExpression

      P2Expression                  -> P1Expression 
      P1Expression "," P2Expression -> P1Expression {cons("Comma")}

      P1Expression -> Expression
      
    context-free syntax  
      %% Some statements require expressions that exclude 'in' expressions
      Expression           -> ExpressionNoIn
      InExpression         -> ExpressionNoIn {reject}
      AssignmentExpression -> AssignmentExpressionNoIn
      InExpression         -> AssignmentExpressionNoIn {reject}
      
           
    lexical restrictions
      "+" -/- [\+]
      "-" -/- [\-]
      "/" -/- [\/]
      
%% 12 Statements
module ecmascript-51/Statements
  exports
    
    context-free syntax
      %% 12.1 Block
      "{" Statement* "}" -> Block {cons("Block")}
      Block              -> Statement
      
      %% 12.2 Variable statement
      "var" {VarDeclaration ","}+  -> AutoSemiStatement {cons("Var")}
      Identifier                   -> VarDeclaration {cons("VarDec")}
      Identifier Initialiser       -> VarDeclaration {cons("VarDecInit")}
      "=" AssignmentExpression     -> Initialiser {cons("Init")}
      %% NoIn variants required by 'for' statements
      Identifier                   -> VarDeclarationNoIn {cons("VarDec")}
      Identifier InitialiserNoIn   -> VarDeclarationNoIn {cons("VarDecInit")}
      "=" AssignmentExpressionNoIn -> InitialiserNoIn {cons("Init")}
      
      %% 12.3 Empty Statement
      ";" -> Statement {cons("Empty")}   
      
      %% 12.4 Expression Statement
      %% TODO: reject expressions starting with { or 'function'
      Expression -> AutoSemiStatement {cons("Expression")}
      
      %% 12.5 if Statement
      "if" "(" Expression ")" Statement                  -> Statement {cons("If"), prefer}
      "if" "(" Expression ")" Statement "else" Statement -> Statement {cons("IfElse")}
      
      %% 12.6.1 do-while Statement
      "do" Statement "while" "(" Expression ")" -> AutoSemiStatement {cons("Do")}
      
      %% 12.6.2 while Statement
      "while" "(" Expression ")" Statement -> Statement {cons("While")}
      
      %% 12.6.3 for Statement
      "for" "(" ExpressionNoIn? ";" Expression? ";" Expression? ")" Statement                 -> Statement {cons("For")}
      "for" "(" "var" {VarDeclarationNoIn ","}+ ";" Expression? ";" Expression? ")" Statement -> Statement {cons("For")}
      
      %% 12.6.4 for-in Statement
      "for" "(" LeftHandSideExpression "in" Expression ")" Statement -> Statement {cons("ForIn")}
      "for" "(" "var" VarDeclarationNoIn "in" Expression ")" Statement   -> Statement {cons("ForIn")}
      
      %% 12.7 continue Statement
      "continue"            -> AutoSemiStatement {cons("Continue")}
      "continue" Identifier -> AutoSemiStatement {cons("Continue"), layout("1.first.line == 2.first.line")}
      
      %% 12.8 break Statement
      "break"            -> AutoSemiStatement {cons("Break")}
      "break" Identifier -> AutoSemiStatement {cons("Break"), layout("1.first.line == 2.first.line")}
      
      %% 12.9 return Statement
      "return"            -> AutoSemiStatement {cons("Return")}
      "return" Expression -> AutoSemiStatement {cons("Return"), layout("1.first.line == 2.first.line")}
     
      %% 12.10 with Statement
      %% Not implemented, considered dangerous

      %% 12.11 switch Statement
      "switch" "(" Expression ")" "{" CaseClause* "}" -> Statement {cons("Switch")}
      "case" Expression ":" Statement*                -> CaseClause {cons("Case")}
      "default" ":" Statement*                        -> CaseClause {cons("Default")}
      
      %% 12.12 Labelled Statements
      Identifier ":" Statement -> Statement {cons("Label")}
      
      %% 12.13 throw Statement
      "throw" Expression -> AutoSemiStatement {cons("Throw"), layout("1.first.line == 2.first.line")}
      
      %% 12.14 try Statement
      "try" Block Catch                -> Statement {cons("TryCatch")}
      "try" Block Finally              -> Statement {cons("TryFinally")}
      "try" Block Catch Finally        -> Statement {cons("TryCatchFinally")}
      "catch" "(" Identifier ")" Block -> Catch {cons("Catch")}
      "finally" Block                  -> Finally {cons("Finally")}

      %% 12.15 debugger Statement
      "debugger" -> Statement {cons("Debugger")}
      
%% 13 Function Declaration
module ecmascript-51/Functions
  exports

    context-free syntax
      "function" Identifier "(" {Identifier ","}* ")" "{" FunctionBody "}" -> FunctionDeclaration {cons("Function")}
      
      FunctionDeclaration                                       -> FunctionExpression
      "function" "(" {Identifier ","}* ")" "{" FunctionBody "}" -> FunctionExpression {cons("Lambda")}
      
      SourceElement* -> FunctionBody {cons("FunctionBody")}
   
%% 14 Program
module ecmascript-51/Program
  exports
    
    context-free start-symbols
      Program
    
    context-free syntax
      SourceElement* -> Program {cons("Program")}

      FunctionDeclaration -> SourceElement
      Statement           -> SourceElement
 
module ECMAScript-51
imports
  ecmascript-51/Program
  ecmascript-51/Functions
  ecmascript-51/Statements
  ecmascript-51/Expressions
  ecmascript-51/AutoSemiInsertion
  ecmascript-51/Literals
  ecmascript-51/Identifiers
  ecmascript-51/Layout
  
module org/sugarj/languages/JavaScript
imports ECMAScript-51
  [ Program   =>    JavaScriptProgram
    SourceElement => JavaScriptSourceElement
    Statement => JavaScriptStatement
    Expression => JavaScriptExpression
    ReservedWord => JavaScriptReservedWord
    Identifier => JavaScriptIdentifier
    NullLiteral => JavaScriptNullLiteral
    BooleanLiteral => JavaScriptBooleanLiteral
    LineTerminatorSequence => JavaScriptLineTerminatorSequence
    NumericLiteral => JavaScriptNumericLiteral
    StringLiteral => JavaScriptStringLiteral ]